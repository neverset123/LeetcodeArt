## 当数组作为参数传递时，它会被转换为指向第一个元素的指针

## erase iterator will automatically set iterator to the next item

## NULL
NULL在cpp中被定义为0， 所以if(NULL)为假

## 范围for循环
与for循环属于不同的循环结构，在不关心迭代索引的情况下推荐使用范围for循环。

## <<和>>
- >>提取运算符，用于从输入流中读取数据(遇空格停止, 同时返回istringstream结构)
- <<插入运算符，用于向输出流写入数据
 
## const/constexpr
- const: 运行时检测变量是否被更改
- cosntexpr: 编译时检测变量是否被更改，常用于类内非整型变量的初始化(需要在初始化时分配内存)

## array/vector
- array: 初始化后不可以更改数组大小(动态申请的数组可以通过realloc更改大小)，比vector更底层，存储和访问的效率更高
- vector:动态扩容

## initializer list
初始化列表比赋值高效。
- 初始化类的数据成员：当创建一个类的对象时，可以使用初始化列表来初始化其数据成员。对于const或引用类型的数据成员必须在对象创建时用初始化列表完成初始化。
- 初始化数组：可以使用初始化列表来初始化数组的元素。
- 初始化容器：C++11引入了一种新的初始化列表语法，可以用来初始化STL容器，如vector，list，set等。

## scope resolution
它涉及到如何在代码中访问不同作用域中的变量和函数。
- 访问全局变量：如果局部作用域和全局作用域有同名的变量，你可以使用作用域解析运算符来访问全局变量。
```
std::cout << ::x << std::endl
```
- 访问类的静态成员：类的静态成员属于类本身，而不是类的任何对象。你可以使用作用域解析运算符来访问它们。
- 在类的外部定义成员函数：如果你在类的声明中只声明了成员函数，而没有定义它们，那么你可以在类的外部使用作用域解析运算符来定义它们。

## malloc/calloc
- malloc：malloc函数在内存中分配指定字节的连续空间。它接受一个参数，即要分配的字节大小。malloc不会初始化分配的内存，所以你可能会看到一些垃圾值。返回void*
- calloc：calloc函数在内存中分配指定数量的指定大小的连续空间。它接受两个参数，一个是元素的数量，另一个是每个元素的大小。calloc会初始化分配的内存为0。返回void*

## 运算符重载
运算符重载是一种允许程序员改变已有运算符的行为的特性。通过运算符重载，你可以为用户自定义的类型（如类）定义运算符的行为。
``` 
Type operator?(args) {};
```

## 复制语义
C++会提供一个默认的拷贝构造函数，它会执行每个数据成员的浅拷贝。然而，对于需要深拷贝的情况（例如，当数据成员包含动态分配的内存或指针时），你需要提供自己的拷贝构造函数。
### 拷贝所有权策略
- 禁止拷贝: 将其拷贝构造函数和拷贝赋值运算符声明为delete，或只声明不定义拷贝构造函数和拷贝赋值运算符
- 所有权转移拷贝：资源的所有权从一个对象转移到另一个对象，通常通过移动构造函数和移动赋值运算符实现。原始对象不再拥有资源，新对象成为资源的唯一所有者。
- 深拷贝：当一个对象被拷贝时，所有的资源都会被复制。这意味着新的对象将有自己的一份资源副本，与原始对象完全独立。这通常通过实现自定义的拷贝构造函数和拷贝赋值运算符来完成。
- 共享所有权拷贝：多个对象共享对同一资源的所有权。这通常通过使用智能指针，如std::shared_ptr，来实现，它们使用引用计数来确保资源在最后一个使用它的对象被销毁时被正确地删除。
#### Rule of Three
如果你的类需要重载以下任何一个操作，那么它很可能需要定义所有三个：析构函数、拷贝构造函数、拷贝赋值函数。
"Rule of Five"是C++11引入移动语义后的一个更新，它取代了旧的"Rule of Three"，
- 析构函数：用于释放对象占用的资源。
- 复制构造函数：用于创建一个新对象作为现有对象的副本。
- 复制赋值运算符：用于将一个对象的值赋给另一个已经存在的对象。
- 移动构造函数：用于创建一个新对象，并从一个即将销毁的对象"窃取"资源。
- 移动赋值运算符：用于将一个对象的值"窃取"给另一个已经存在的对象。


