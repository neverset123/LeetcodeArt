## 关键字
### const
- 声明常量，运行时不可以改变
- 限定函数参数在函数内不能被改变
- 限定成员函数：
    - 常成员函数不能修改类的任何成员变量（除非他们被声明为mutable）
    - 常成员函数不能调用非常成员函数；
    - 常对象只能调用其类的常成员函数，不能调用非常成员函数
- 限定成员变量
    必须在声明时或在构造函数的初始化列表中进行初始化
- 限定指针：
    - 指向常量的指针：const int* ptr
    指针的值可以被修改，但是指向对象的值不能被修改
    - 常指针：int* const ptr
    必须进行初始化，指针的值（它指向的地址）不能被修改，指向对象的值可以被修改。
- 限定实例化对象
    默认为文件局部变量，需用extern 显式修饰才能在文件外访问。

在C中用const不能定义真正意义上的常量，c中的const仅仅是从编译层来限定，不允许对const 变量进行赋值操作，在运行期是无效的（通过指针对const变量是可以修改值的），c++在编译时会把const常量加入符号表，遇到这个变量会从符号表中查找，所以在C++中是不可能修改到const变量的。

### static
- 静态局部变量
    函数内部声明的静态变量，只在函数内部可见，生命周期是整个程序执行期。但是函数调用不会被重新初始化
- 静态类成员变量
    在类中声明的静态变量由所有对象共享，只能在类外初始化
- 静态类成员函数
    它没有this指针，因此只能访问静态成员变量和静态成员函数，不能访问非静态变量和函数；可以直接通过类名和范围解析运算符调用，不需要创建类的对象；它不依赖于类的对象且不能修改类的成员变量，因此不能被const或volatile修饰（const或volatile成员函数需要this指向所操作的对象）。
- 静态全局变量和函数
    只在声明它们的文件中可见

### volatile
一种类型修饰符，使用 volatile 告诉编译器不应对这样的对象进行优化。每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）。但它并不能保证多线程安全，需要使用互斥锁等同步机制。
- 当const和volatile同时修饰一个变量表示这个变量是只读的并且不应对它进行优化(如只读的状态寄存器)
- 指针可以是volatile(如中断服务子程序修改一个指向一个buffer的指针)

### explicit
- 防止构造函数隐式类型转换;
- 防止转换函数隐式类型转换

### friend
声明友元函数或友元类，可以访问类的私有或保护成员。
- 友元函数通过对象来访问该类的私有或保护成员。
- 友元类的声明在该类的声明中，而实现在该类外。
优点：提高了程序的运行效率。
缺点：破坏了类的封装性和数据的透明性。
特点：
- 友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。
- 友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员。

### using
- 导入命名空间
- 改变基类中成员函数和成员变量的访问权限
- 将基类函数重载到派生类
- 定义类型别名

### decltype
用于检查实体的声明类型或表达式的类型
- 泛型编程中结合auto，指定函数的返回值类型
- 使用decltype获取匿名结构体的类型
- decltype（e），
    - e是一个被重载的函数会导致编译错误
    - 如果e是一个将亡值。推导为类型的右值引用
    - 如果e是一个左值。推导为类型的引用
    - 以上都不是，则推导为本类型

### inline
- 避免函数调用开销，不需要跳转到被调用函数的地址去执行，直接在当前代码段执行。内联是以代码膨胀(复制)为代价。
- 虚函数通常不能内联，因为内联函数需要在编译时知道函数的实现。虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

### virtual
虚函数是实现运行时多态的一种机制：父类中虚函数为子类提供默认的函数实现，子类可以重写父类的虚函数实现子类的特殊化
- 虚函数是为了允许用基类的指针来调用子类的这个函数。
- 纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

虚函数表（Virutal Function Table，vtbl）和虚函数指针（Virutal Function Pointer，vtpr）是实现运行时多态的关键。虚函数表是存储类虚函数地址的数组，每个类的对象都有一个虚函数指针指向虚函数表。
- 虚函数不能是静态函数
虚函数依靠vptr和vtable来处理。静态成员函数没有this指针，无法访问vptr。
- 构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。vptr是在运行阶段实例化对象时才产生的。如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。
- 析构函数可以声明为虚函数。当类被用作基类时， 就应该声明虚析构函数(否则删除派生类对象时，只调用基类的析构函数，导致资源泄露)。
- 虚函数不可以为私有函数，因为vptr无法访问私有函数

## 宏
### assert
断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。
- 断言通常在运行时被禁用。在代码开头加上#define NDEBUG

### 字符串操作符# 
在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组。
- 忽略传入参数名前面和后面的空格
- 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。
### 符号连接操作符（##）
“##”是一种分隔连接方式，它的作用是先分隔然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。
- 当用##连接形参时，##前后的空格可有可无。
- 连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。
- 如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。
### 续行操作符（\）
当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。

## 数据结构
### 位字段Bit field 
特殊数据结构，把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作，节省存储空间。
通过在结构体中声明一个特殊类型的成员变量来定义，变量类型必须为整数类型。

### union
在相同的内存位置存储不同的数据类型，大小等于其最大成员的大小。

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员（引用类型没有自己的独立存储空间）
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名union在定义所在作用域可直接访问union成员
- 匿名union不能包含protected成员或private成员
- 全局匿名union必须是静态（static）或全局的

### enum
c++11中enum class的作用域是局部的（传统的enum是全局的）；不能隐式转换成其他类型。枚举常量不会占用对象的存储空间，它们在编译时被全部求值。
缺点：
- 隐含数据类型是整数，其最大值有限，且不能表示浮点。

### 结构体struct
- C++结构体中不仅可以定义数据，还可以定义函数。
- C++结构体中可以使用访问修饰符，如：public、protected、private 。
- C++结构体可以直接使用不带struct,如果结构体名和变量名不冲突。
- C++结构体可以继承
- 结构体的名字可以与函数名相同，因为他们存在于不同的命名空间(只适用于带struct定义的结构体,不适用typedef定义结构体别名)
- 默认的访问权限(struct是public的，class是private的)

### 引用与指针
引用时已存在变量的别名；指针是一个存储了另一个变量地址的变量
- 引用必须初始化，而指针可以不初始化。
- 引用不能为空，而指针可以为空。
- 引用不能更换目标,而指针可以
- 非内部数据类型的引用作为形参可以提高函数效率。

指针参数传递和引用参数传递：
- 指针传递只能改变所指对象的值，不能改变指针本身
- 引用传递既可以改变对象内容，也可以改变指针本身

### 左值(left value,lvalue)，将亡值(expiring value,xvalue)，纯右值(pure rvalue,pralue)
- 左值：可以取地址的，有名字的，非临时的
- 右值：不能取地址的，没有名字的，临时的
    - 纯右值: 
        - 本身就是赤裸裸的、纯粹的字面值，如3、false；
        - 求值结果相当于字面值或是一个不具名的临时对象。
    - 将亡值
        - 返回右值引用的函数的调用表达式
        - 转换为右值引用的转换函数的调用表达式


### 左值引用和右值引用
- 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用
- 右值引用(类型 && 引用名 = 右值表达式)， 用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。
优点：
    + 消除两个对象交互时不必要的对象拷贝。
    + 能够更简洁明确地定义泛型函数，实现完美转发。

### 智能指针
- std::unique_ptr
独占所有权的智能指针，同一时间只能有一个unique_ptr指向给定对象。
- std::shared_ptr
共享所有权的智能指针
- std::weak_ptr
不拥有所有权的智能指针，与shared_ptr共同使用，防止shared_ptr之间循环引用

### 野指针
野指针：指向内存被释放的内存或者没有访问权限的内存的指针。
避免野指针
- 将指针初始化为NULL
char * p = NULL;
- 用malloc分配内存
char * p = (char * )malloc(sizeof(char));
- 用已有合法的可访问的内存地址对指针初始化
char num[30] = {0};
char *p = num;
- 指针用完后释放内存，将指针赋NULL。
delete(p);
p = NULL;

### STL vector
是一种动态数组，可以再运行时增长和缩小，允许快速随机访问，并且可以在尾部进行高效插入和删除。
采用成倍方式扩容可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。
vector内存空间是在vector对象被销毁（离开其作用域或者被delete动态销毁）或者调用clear+shrink_to_fit时才被释放。
- empty()用来检测容器是否为空的
- clear()可以清空所有元素(内存不释放)
- swap()可以将所有元素清空并释放内存。

### list、queue、deque、vector区别
- std::list是双向链表（存储空间不连续），允许在任何位置进行高效的插入和删除操作，不支持快速随机访问；插入操作和结合操作不会使list迭代器失效;
- std::deque是序列容器（双端队列），允许在两端进行高效的插入和删除操作，支持随机访问，动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来
- std::queue是容器适配器，提供了FIFO的数据结构，不支持随机访问。底层是由std::deque或std::list实现
- std::vector是动态数组，允许快速随机访问，可以在尾部进行高效的插入和删除，动态扩容需要复制整个数组。

## 存储
### 内存类型
堆(malloc)、栈(如局部变量、函数参数)、程序代码区（存放二进制代码）、全局/静态存储区（全局变量、static变量）和常量存储区（常量）。
- 全局变量、static变量会初始化为缺省值，而堆和栈上的变量是随机的。
- 堆存放程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制；
- 栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在

堆和自由存储的区别：
- 堆提供了低级的动态分配的功能，调用malloc()和free分配和释放内存。
- 自由存储是通过new和delete动态分配和释放对象，通过new来申请的内存区域可称为自由存储区。它不仅负责内存的分配和释放，还会调用对象的构造和析构函数。

### new和malloc的区别
malloc申请的存储空间不能用delete释放, malloc/free不能执行构造函数与析构函数，所以不支持动态对象。

- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
- new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成需要的类型。
- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

## 编译
### extern "C"
告诉编译器寻找C的语言符号

### ::
- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

### ifndef/define/endif和 program once 的区别
相同点:
- 它们的作用是防止头文件被重复包含。
不同点:
- ifndef 由语言本身提供支持，但是 program once 一般由编译器提供支持
- 通常运行速度上 ifndef 一般慢于 program once

### do{...}while(0)
- 可以避免空宏警告
- 创建局部作用域，保证宏正确扩展
- 避免使用goto控制流（do while + break实现跳转）

### 动态库和静态库
- 静态库链接的时候把库直接加载到程序中，静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库
- 动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度




