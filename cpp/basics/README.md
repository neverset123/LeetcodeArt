1. const
•	限定变量值不可以改变，从而保护被修饰的东西
•	被const修饰的成员函数代表不能修改成员变量的值， const成员函数只能调用const成员函数；
•	只读对象。只读对象只能调用const成员函数
const对象默认为文件局部变量，需用extern 显式修饰才能在文件外访问
1）指向常量的指针
不能使用void*指针保存const对象的地址，必须使用const void*类型的指针保存const对象的地址
2）常指针()
const指针必须进行初始化，且const指针的值不能修改。
3）类中使用const
只有常成员函数才有资格操作常量或常对象;类中的const成员变量必须通过初始化列表进行初始化

如果关键字 const 直接写在“*p”前，则程序不能修改“*p”，但可以修改 p；如果关键字 const 直接写在 p 前，则程序不能修改的是 p，但可以通过“*p”来修改它所指内存的值。
2. static
静态变量的空间也只分配一次;类中的静态变量由对象共享;允许使用对象和'.'来调用静态成员函数,但建议使用类名和范围解析运算符调用静态成员
3. 虚函数
虚函数主要是“运行时多态”，父类中虚函数为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化
•	定义虚函数是为了允许用基类的指针来调用子类的这个函数。
•	定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
虚函数表（Virutal Function Table，vtbl）、虚函数指针（Virutal Function Pointer，vtpr）。编译器会为每个存在虚函数（包括继承而来的虚函数）的类对象中插入一个指针vtpr，该vtpr指向存储虚函数的虚函数表vtbl。vtbl就是个数组，每个槽存储的都是虚函数的地址。
* 静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰。
虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr
* 构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。
尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。
* 析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。
* 虚函数不可以为私有函数，因为vptr无法访问私有函数
* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
4. volatile
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
* 一个参数既可以是const还可以是volatile(如只读的状态寄存器)
* 指针可以是volatile(如中断服务子程序修该一个指向一个buffer的指针)
5. assert
断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。
* 断言通常在运行时被禁用。在代码开头加上#define NDEBUG
6. Bit field 
数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作，节省存储空间。
7. union
多变量共享一段内存
```
    默认访问控制符为 public
    可以含有构造函数、析构函数
    不能含有引用类型的成员
    不能继承自其他类，不能作为基类
    不能含有虚函数
    匿名 union 在定义所在作用域可直接访问 union 成员
    匿名 union 不能包含 protected 成员或 private 成员
    全局匿名联合必须是静态（static）的
```
8. extern "C"
告诉编译器寻找C的语言符号
9. struct
* C++结构体中不仅可以定义数据，还可以定义函数。
* C++结构体中可以使用访问修饰符，如：public、protected、private 。
* C++结构体使用可以直接使用不带struct。
* C++继承
* 若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只用用带struct的！且不适用typedef定义结构体别名
* 默认的继承访问权限。struct 是 public 的，class 是 private 的。

10. explicit
explicit 修饰构造函数时，可以防止隐式转换和复制初始化;explicit 修饰转换函数时，可以防止隐式转换
11. friend
提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员的机制。友元函数可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。友元类的声明在该类的声明中，而实现在该类外。
优点：提高了程序的运行效率。
缺点：破坏了类的封装性和数据的透明性。
```
    友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。

    友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。
```
12. using
* 根据条件使用不同命名空间的函数
* 改变类中成员函数和成员变量的访问权限
* 在派生类中使用using声明语句指定一个名字而不指定形参列表， 可以把该函数的所有重载实例添加到派生类
* 使用using B=A 进行类型别名
13. ::
```
    全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
    类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
    命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的
```

14. enum
c++11中enum的作用域不在是全局的；不能隐式转换成其他类型
```
枚举常量不会占用对象的存储空间，它们在编译时被全部求值。
枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点。
```
15. decltype
查询表达式的类型
* 泛型编程中结合auto，用于追踪函数的返回值类型
* 使用匿名的结构体
* decltype（e），如果e是一个被重载的函数，则会导致编译错误
* decltype（e），如果e是一个将亡值。推导为类型的右值引用
* decltype（e），如果e是一个左值。推导为类型的引用
* 以上都不是，则推导为本类型

16. 引用与指针
•	引用必须初始化，而指针可以不初始化。
•	引用不能为空，而指针可以为空。
•	引用不能更换目标,而指针可以
非内部数据类型的引用作为形参可以提高函数效率。
指针参数传递和引用参数传递：
•	两者都会在函数内生成临时变量
•	指针传递只能改变所指对象的值，不能改变指针本身
•	引用传递既可以改变对象内容，也可以改变指针本身

* 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用
* 右值引用(类型 && 引用名 = 右值表达式)， 用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期

    + 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
    + 能够更简洁明确地定义泛型函数。
17. 宏
1）字符串操作符# 
在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组。
* 忽略传入参数名前面和后面的空格
* 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。
2） 符号连接操作符（##）
“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。
* 当用##连接形参时，##前后的空格可有可无。
* 连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。
* 如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。
3）续行操作符（\）
当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。

18. do{...}while(0)
* 可以避免空宏Warning
* 避免使用goto控制流
* 缩小变量作用域

20. 内联函数
避免函数调用开销，不需要跳转到被调用函数的地址去执行，直接在当前代码段执行。内联是以代码膨胀(复制)为代价。虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

21. 动态库和静态库
•	静态库链接的时候把库直接加载到程序中，静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库
•	动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度

22. 内存类型
堆(malloc)、栈(如局部变量、函数参数)、程序代码区（存放二进制代码）、全局/静态存储区（全局变量、static变量）和常量存储区（常量）。
全局变量、static变量会初始化为缺省值，而堆和栈上的变量是随机的。
•	堆存放动态分配的对象, 即在程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制；
•	栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在
23. 堆和自由存储区的区别
•	堆提供了动态分配的功能，调用malloc()和free分配和释放内存。
•	自由存储是通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。所有的C++编译器默认使用堆来实现自由存储

24. 左值(left value,lvalue)，将亡值(expiring value,xvalue)，纯右值(pure rvalue,pralue)
•	左值：可以取地址的，有名字的，非临时的
•	右值：不能取地址的，没有名字的，临时的
    - 纯右值: 
        - 本身就是赤裸裸的、纯粹的字面值，如3、false；
        - 求值结果相当于字面值或是一个不具名的临时对象。
    - 将亡值
        - 返回右值引用的函数的调用表达式
        - 转换为右值引用的转换函数的调用表达式

25. new和malloc的区别
malloc申请的存储空间不能用delete释放, malloc/free不能执行构造函数与析构函数，所以不支持动态对象

•	new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
•	使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
•	new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成需要的类型。
•	new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
•	malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

26. 在C中用const 能定义真正意义上的常量吗？C++中的const呢
不能。c中的const仅仅是从编译层来限定，不允许对const 变量进行赋值操作，在运行期是无效的（通过指针对const变量是可以修改值的），c++在编译时会把const常量加入符号表，遇到这个变量会从符号表中查找，所以在C++中是不可能修改到const变量的。

27. 头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别
相同点:
•	它们的作用是防止头文件被重复包含。
不同点:
•	ifndef 由语言本身提供支持，但是 program once 一般由编译器提供支持
•	通常运行速度上 ifndef 一般慢于 program once

28. STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间
采用成倍方式扩容可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容
vector所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素(内存不释放)，swap()可以将所有元素清空并释放内存。

29. list与queue之间的区别
•	list不能够以普通指针作为迭代器，因为其在存储空间中不连续存在；
•	list插入操作和结合操作不会使list迭代器失效;
•	list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；
•	deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。

30. 野指针
野指针：指向内存被释放的内存或者没有访问权限的内存的指针。
避免野指针
•	将指针初始化为NULL
char * p = NULL;
•	用malloc分配内存
char * p = (char * )malloc(sizeof(char));
•	用已有合法的可访问的内存地址对指针初始化
char num[ 30] = {0};
char *p = num;
•	指针用完后释放内存，将指针赋NULL。
delete(p);
p = NULL;

31. 智能指针
智能指针（std::shared_ptr和std::unique_ptr）可以实现自动的内存管理
