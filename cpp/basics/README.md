1.const
作用: 定义常量，防止修改。
const对象默认为文件局部变量，需用extern 显式修饰才能在文件外访问
1）指向常量的指针
不能使用void*指针保存const对象的地址，必须使用const void*类型的指针保存const对象的地址
2）常指针()
const指针必须进行初始化，且const指针的值不能修改。
3）类中使用const
只有常成员函数才有资格操作常量或常对象;类中的const成员变量必须通过初始化列表进行初始化
2. static
静态变量的空间也只分配一次;类中的静态变量由对象共享;允许使用对象和'.'来调用静态成员函数,但建议使用类名和范围解析运算符调用静态成员
3. 虚函数

虚函数表（Virutal Function Table，vtbl）、虚函数指针（Virutal Function Pointer，vtpr）。编译器会为每个存在虚函数（包括继承而来的虚函数）的类对象中插入一个指针vtpr，该vtpr指向存储虚函数的虚函数表vtbl。vtbl就是个数组，每个槽存储的都是虚函数的地址。
* 静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰。
虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr
* 构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。
尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。
* 析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。
* 虚函数不可以为私有函数，因为vptr无法访问私有函数
* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
4. volatile
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
* 一个参数既可以是const还可以是volatile(如只读的状态寄存器)
* 指针可以是volatile(如中断服务子程序修该一个指向一个buffer的指针)
5. assert
断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。
* 断言通常在运行时被禁用。在代码开头加上#define NDEBUG
6. Bit field 
数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作，节省存储空间。
7. union
多变量共享一段内存
```
    默认访问控制符为 public
    可以含有构造函数、析构函数
    不能含有引用类型的成员
    不能继承自其他类，不能作为基类
    不能含有虚函数
    匿名 union 在定义所在作用域可直接访问 union 成员
    匿名 union 不能包含 protected 成员或 private 成员
    全局匿名联合必须是静态（static）的
```
8. extern "C"
告诉编译器寻找C的语言符号
9. struct
* C++结构体中不仅可以定义数据，还可以定义函数。
* C++结构体中可以使用访问修饰符，如：public、protected、private 。
* C++结构体使用可以直接使用不带struct。
* C++继承
* 若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只用用带struct的！且不适用typedef定义结构体别名
* 默认的继承访问权限。struct 是 public 的，class 是 private 的。

10. explicit
explicit 修饰构造函数时，可以防止隐式转换和复制初始化;explicit 修饰转换函数时，可以防止隐式转换
11. friend
提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员的机制。友元函数可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。友元类的声明在该类的声明中，而实现在该类外。
优点：提高了程序的运行效率。
缺点：破坏了类的封装性和数据的透明性。
```
    友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。

    友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。
```
12. using
* 根据条件使用不同命名空间的函数
* 改变类中成员函数和成员变量的访问权限
* 在派生类中使用using声明语句指定一个名字而不指定形参列表， 可以把该函数的所有重载实例添加到派生类
* 使用using B=A 进行类型别名
13. ::
```
    全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
    类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
    命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的
```

14. enum
c++11中enum的作用域不在是全局的；不能隐式转换成其他类型
```
枚举常量不会占用对象的存储空间，它们在编译时被全部求值。
枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点。
```
15. decltype
查询表达式的类型
* 泛型编程中结合auto，用于追踪函数的返回值类型
* 使用匿名的结构体
* decltype（e），如果e是一个被重载的函数，则会导致编译错误
* decltype（e），如果e是一个将亡值。推导为类型的右值引用
* decltype（e），如果e是一个左值。推导为类型的引用
* 以上都不是，则推导为本类型
16. 引用与指针
* 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用
* 右值引用(类型 && 引用名 = 右值表达式)， 用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期

    + 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
    + 能够更简洁明确地定义泛型函数。
17. 宏
1）字符串操作符# 
在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组。
* 忽略传入参数名前面和后面的空格
* 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。
2） 符号连接操作符（##）
“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。
* 当用##连接形参时，##前后的空格可有可无。
* 连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。
* 如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。
3）续行操作符（\）
当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。

18. do{...}while(0)
* 可以避免空宏Warning
* 避免使用goto控制流
* 缩小变量作用域





