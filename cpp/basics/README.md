## 关键字
### const
- 限定变量值不可以改变
- 被const修饰的成员函数不能修改成员变量的值， const成员函数只能调用const成员函数；只有常成员函数才有资格操作常量或常对象
- 只读对象。只读对象只能调用const成员函数

const对象默认为文件局部变量，需用extern 显式修饰才能在文件外访问。
- 指向常量的指针
不能使用void*指针保存const对象的地址，必须使用const void*类型的指针保存const对象的地址
- 常指针()
const指针必须进行初始化，且const指针的值不能修改。
- 类中使用const
类中的const成员变量必须通过初始化列表进行初始化

如果关键字 const 直接写在“*p”前，则程序不能修改“*p”，但可以修改 p；如果关键字 const 直接写在 p 前，则程序不能修改的是 p，但可以通过“*p”来修改它所指内存的值。
在C中用const不能定义真正意义上的常量，c中的const仅仅是从编译层来限定，不允许对const 变量进行赋值操作，在运行期是无效的（通过指针对const变量是可以修改值的），c++在编译时会把const常量加入符号表，遇到这个变量会从符号表中查找，所以在C++中是不可能修改到const变量的。

### static
静态变量的空间只分配一次;类中的静态变量由对象共享;允许使用对象和'.'来调用静态成员函数,但建议使用类名和范围解析运算符调用静态成员

### volatile
一种类型修饰符，使用 volatile 告诉编译器不应对这样的对象进行优化。
volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
* 一个参数既可以是const还可以是volatile(如只读的状态寄存器)
* 指针可以是volatile(如中断服务子程序修改一个指向一个buffer的指针)

### explicit
explicit修饰构造函数时，可以防止隐式类型转换和复制初始化;explicit 修饰转换函数时，可以防止隐式类型转换

### friend
提供了一种普通函数或者类成员函数 访问另一个类中的私有或保护成员的机制。友元函数可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。友元类的声明在该类的声明中，而实现在该类外。
优点：提高了程序的运行效率。
缺点：破坏了类的封装性和数据的透明性。
特点：
- 友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。
- 友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。

### using
- 导入命名空间
- 改变基类中成员函数和成员变量的访问权限
- 将基类函数重载到派生类
- 定义类型别名

### decltype
推断表达式的类型
- 泛型编程中结合auto，指定函数的返回值类型
- 使用decltype获取匿名结构体的类型
- decltype（e），
    - e是一个被重载的函数会导致编译错误
    - 如果e是一个将亡值。推导为类型的右值引用
    - 如果e是一个左值。推导为类型的引用
    - 以上都不是，则推导为本类型

### virtual
虚函数主要是“运行时多态”，父类中虚函数为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化
- 定义虚函数是为了允许用基类的指针来调用子类的这个函数。
- 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

虚函数表（Virutal Function Table，vtbl）、虚函数指针（Virutal Function Pointer，vtpr）。编译器会为每个存在虚函数（包括继承而来的虚函数）的类对象中插入一个指针vtpr，该vtpr指向存储虚函数的虚函数表vtbl。vtbl就是个数组，每个槽存储的都是虚函数的地址。
- 静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰。
虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr
- 构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。
- 析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。
- 虚函数不可以为私有函数，因为vptr无法访问私有函数
- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。

### inline
- 避免函数调用开销，不需要跳转到被调用函数的地址去执行，直接在当前代码段执行。内联是以代码膨胀(复制)为代价。
- 虚函数通常不能内联，因为内联函数需要再编译时知道函数的实现。虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

## 宏
### assert
断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。
- 断言通常在运行时被禁用。在代码开头加上#define NDEBUG

### 字符串操作符# 
在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组。
- 忽略传入参数名前面和后面的空格
- 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。
### 符号连接操作符（##）
“##”是一种分隔连接方式，它的作用是先分隔然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。
- 当用##连接形参时，##前后的空格可有可无。
- 连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。
- 如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。
### 续行操作符（\）
当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。

## 数据结构
### 位字段Bit field 
特殊数据结构，把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作，节省存储空间。
通过在结构体中声明一个特殊类型的成员变量来定义，变量类型必须为整数类型。

### union
多变量共享一段内存；

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

### 结构体struct
- C++结构体中不仅可以定义数据，还可以定义函数。
- C++结构体中可以使用访问修饰符，如：public、protected、private 。
- C++结构体可以直接使用不带struct,如果结构体名和变量名不冲突。
- C++结构体可以继承
- 结构体的名字可以与函数名相同(只适用于带struct定义的结构体,不适用typedef定义结构体别名)
- 默认的继承访问权限(struct是public的，class是private的)

### enum
c++11中enum的作用域不再是全局的；不能隐式转换成其他类型。枚举常量不会占用对象的存储空间，它们在编译时被全部求值。
缺点：
- 隐含数据类型是整数，其最大值有限，且不能表示浮点。

### 引用与指针
- 引用必须初始化，而指针可以不初始化。
- 引用不能为空，而指针可以为空。
- 引用不能更换目标,而指针可以
- 非内部数据类型的引用作为形参可以提高函数效率。

指针参数传递和引用参数传递：
- 指针传递只能改变所指对象的值，不能改变指针本身
- 引用传递既可以改变对象内容，也可以改变指针本身

### 左值(left value,lvalue)，将亡值(expiring value,xvalue)，纯右值(pure rvalue,pralue)
- 左值：可以取地址的，有名字的，非临时的
- 右值：不能取地址的，没有名字的，临时的
    - 纯右值: 
        - 本身就是赤裸裸的、纯粹的字面值，如3、false；
        - 求值结果相当于字面值或是一个不具名的临时对象。
    - 将亡值
        - 返回右值引用的函数的调用表达式
        - 转换为右值引用的转换函数的调用表达式


### 左值引用和右值引用
- 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用
- 右值引用(类型 && 引用名 = 右值表达式)， 用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。
优点：
    + 消除两个对象交互时不必要的对象拷贝。
    + 能够更简洁明确地定义泛型函数，实现完美转发。

### 智能指针
- std::shared_ptr
独占所有权的智能指针，同一时间只能有一个unique_ptr指向给定对象。
- std::unique_ptr
共享所有权的智能指针
- std::weak_ptr
不拥有所有权的智能指针，与shared_ptr共同使用，防止shared_ptr之间循环引用

### 野指针
野指针：指向内存被释放的内存或者没有访问权限的内存的指针。
避免野指针
- 将指针初始化为NULL
char * p = NULL;
- 用malloc分配内存
char * p = (char * )malloc(sizeof(char));
- 用已有合法的可访问的内存地址对指针初始化
char num[ 30] = {0};
char *p = num;
- 指针用完后释放内存，将指针赋NULL。
delete(p);
p = NULL;

### STL vector
是一种动态数组，可以再运行时增长和缩小，允许快速随机访问，并且可以在尾部进行高效插入和删除。
采用成倍方式扩容可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。
vector所有内存空间是在vector析构时候才能被系统回收。
- empty()用来检测容器是否为空的
- clear()可以清空所有元素(内存不释放)
- swap()可以将所有元素清空并释放内存。

### list、queue、deque、vector区别
- std::list是双向链表（存储空间不连续），允许在任何位置进行高效的插入和删除操作，不支持快速随机访问；插入操作和结合操作不会使list迭代器失效;
- std::deque是序列容器（双端队列），允许在两端进行高效的插入和删除操作，支持随机访问，动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来
- std::queue是容器适配器，提供了FIFO的数据结构，不支持随机访问。底层是由std::deque或std::list实现
- std::vector是动态数组，允许快速随机访问，可以在尾部进行高效的插入和删除，动态扩容需要复制整个数组。

## 存储
### 内存类型
堆(malloc)、栈(如局部变量、函数参数)、程序代码区（存放二进制代码）、全局/静态存储区（全局变量、static变量）和常量存储区（常量）。
- 全局变量、static变量会初始化为缺省值，而堆和栈上的变量是随机的。
- 堆存放程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制；
- 栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在

堆和自由存储的区别：
- 堆提供了低级的动态分配的功能，调用malloc()和free分配和释放内存。
- 自由存储是通过new和delete动态分配和释放对象，通过new来申请的内存区域可称为自由存储区。它不仅负责内存的分配和释放，还会调用对象的构造和析构函数。

### new和malloc的区别
malloc申请的存储空间不能用delete释放, malloc/free不能执行构造函数与析构函数，所以不支持动态对象。

- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
- new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成需要的类型。
- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

## 编译
### extern "C"
告诉编译器寻找C的语言符号

### ::
- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

### ifndef/define/endif和 program once 的区别
相同点:
- 它们的作用是防止头文件被重复包含。
不同点:
- ifndef 由语言本身提供支持，但是 program once 一般由编译器提供支持
- 通常运行速度上 ifndef 一般慢于 program once

### do{...}while(0)
- 可以避免空宏警告
- 创建局部作用域，保证宏正确扩展
- 避免使用goto控制流（do while + break实现跳转）

### 动态库和静态库
- 静态库链接的时候把库直接加载到程序中，静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库
- 动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度




